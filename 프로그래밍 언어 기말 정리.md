

1. **구조적 프로그래밍을 위한 세 가지 제어구조에 대해 설명하시오.(10)**
- 구조적 프로그래밍은 goto 문을 사용하지 않고, 시작과 끝나는 지점이 일정한 구조적 구문을 사용하자는 것
- 각각의 구조와 그 사이의 관계를 이해하면 프로그램 전체를 보다 쉽게 이해할 수 있다는 장점
- 간단 + 계층적인 제어구조
	1. 순차 
		1. 구문 순서에 따라서 순서대로 수행하는 것 
	2. 선택 
		1. 프로그램의 상태에 따라서 여러 구문들 중에서 하나를 수행하는 것, fi, switch 와 같은 키워드 사용
	3. 반복
		1. 프로그램이 특정한 상태에 도달할 때까지 구문을 반복하여 수행하거나 집합체의 각각의 원소들에 대해 어떤 구문을 반복 수행하는 것, while, repeat, for와 같은 키워드로 표현

2. **if-문을 사용하여 다음 switch-문과 똑같은 일을 하도록 작성하시오(10점)**

``` python
switch (E) {

case a : S1; break; case b : S2; break;

case c : S3; break;

}
```
-----
``` python
if (E == a) { S1; } 
else if (E == b) { S2; } 
else if (E == c) { S3; }
```
3. **정적 타입 언어와 동적 타입 언어에 대해서 설명하시오.(5점)**
	1. 정적타입언어 
		1. 변수의 타입이 컴파일 시간에 결정되어 고정되는 언어로 보통 타입 검사도 컴파일 시간에 한다.
		2. JAVA, C, C++, FORTRAN, Pascal, Scala 등이 대표적
		3. JAVA, C, C++에서 string 타입으로 선언된 변수 name은 한 번 타입 선언되면 타입이 고정되어 변할 수 없다 . (JAVA 예시 : String name; name = "joo"; name = 35; //오류 발생)
	2. 동적타입언어
		1. 변수의 타입이 고정되지 않고 실행중에 변하는 언어
		2. JavaScript, Perl, Python, Sheme 등이 대표적
		3. JavaScript를 예로 들었을 때 변수 name은 선언된 타입이 없고 대입값에 따라 타입이 변경됨 ( var name; name="joo"; name =34; //오류 발생 X)
		4. 타입 검사도 인터프리터에 의해서 실행 중에 이뤄진다.
		5. Python경우 type연산자를 통해 확인 가능
**４. 다음 Python의 예를 실행하고 결과를 타입 관점에서 설명하시오.(20점)**
``` python
>> def add(a,b): return a+b
>> add(5, 10.0)
  1)15.0
>> add(5, “10”)	
  2) TypeError : unsupportted operand type(s) for + : 'int' and 'str'
>> add(“hello”, “world”)
  3) helloworld
>> add([1,3,5], [7,9])
  4) [1, 3, 5, 7, 9]
```
1) a = 5(성수, int), b = 10.0(실수, float)
   python에서 int + float 연산은 자동으로 float 로 변환하여 실수로 반환
   python은 숫자 연산에서 더 정밀한 타입을 유지하려고 함 
2) a=5(정수, int) b="10"(문자열, str)
   python은 int와 str 연산을 자동으로 해주지 않음
   따라서 TypeError 발생하고, 계산하려면 문자열 변경후 연산 해야함
3) a="hello"(문자열, str) , b="world"(문자열, str)
   python에서 str + str은 결합하는 연산으로 helloworld 출력
4) a=[1,3,5], b=[7, 9]
   a=[1,3,5] (리스트, list), b = [7,9](리스트, list)
   python은 리스트에 대해 덧셈 연산자를 리스트 연결연산으로 해석
   새로운리스트 반환
   
   

6. **자료구조에서 배열과 스택에 대해 설명하시오(10점)**
- 배열 
	- 같은 타입의 연속된 변수들로 구성하는 자료형
	- 배열을 구성하는 변수 하나하나를 배열 요소라고 하고, ㄹ배열요소는 배열 이름과 순서를 나타내는 인덱스 
	- 1차원 배열과 2차원 배열, 그 이상의 배열이 있지만, 기본적으로 배열은 1차원 메모리에 저장된다. 
	- 인덱스를 통해서 빠른 접근이 가능하고, 인덱스는 0에서부터 시작된다.
	- 언어별로 배열 크기가 동적으로 결정되는 시점이 다르지만, 배열의 크기가 한 번 결정되면 그 크기는 고정되는 것은 동일하다.
	- 단순 데이터 저장
- 스택
	- LIFO 원칙을 따르는 선형 데이터 구조 
	- 가장 최근에 삽입된 데이터가 가장 먼저 제거됨
	- 삽입(push) 삭제(pop)는 스택의 맨 위(top)에서만 수행
	- 파이썬 기준으로 할 때 stack을 선언시 배열을 사용하여 생성할 수 있다.
		stack = []
		stack.append(10) #push
		stack.append(20)
		print(stack.pop()) #pop 
	- 스택은 크기를 초과할 경우 스택오버플로우 발생, 이를 해결하기 위해 동적배열을 사용하여 배열 크기를 자동으로 늘릴 수 있다. (python 리스트 사용)
	- 특정 알고리즘(깊이우선탐색  등) 에서 유용
- 공통점 
	- 선형데이터 구조, 인덱스 기반 저장, 연속된 메모리 

6. **강한 타입 언어와 약한 타입 언어에 대해서 설명하시오(5점)**
- 강한 타입 언어 
	- 엄격한 타입 규칙을 적용하여(=가능한 모든) 타입오류를 찾아낼 수 있는 언어를 강한타입 언어
	- JAVA, C#, Python 등
	- 자동타입 변환을 하지않고 엄격한 타입 규칙을 적용하여 타입검사를 하기때문에 이를 통과한 프로그램은 실행 중에 타입 오류가 바랭하지 않음
- 약한 타입 언어
	- 느슨한 타입 규칙을 적용하여 타입 오류를 찾아내는 언어
	- C/C++, JavaScript, PHP 등
	- 자동 타입 변환을 하고 타입규칙이 엄격하지 않아서 타입규칙을 적용하여 타입 검사를 하더라도 해당 검사를 통과한 프로그램이 실행중에 타입 오류가 발생할 수 있음
- 강한정적타입언어 : JAVA
- 약한정적타입언어 : C
- 강한동적타입언어 : Python
- 약한동적타입언어 : JavaScript

7. **포인터 타입과 참조 타입에 대해서 자세히 설명하시오(20점)**
- 포인터 타입
	- 메모리 위치(주소)를 값으로 사용하는 자료형
	- 대표적으로 C, C에서는 메모리 위치도 하나의 값처럼 사용할 수 있으며 이를 포인터라고 부름
	- c를 기준
		``` c
		T *p; // 포인터 변수 선언
		p = E; //포인터 변수에 대입
		*p = E; // 포인터가 참조하는 변수에 대입
		```
		- malloc(n) : 크기 n의 메모리 할당 및 시작 주소 반환
		- &x : 변수 x의 포인터(주소)
		- \*p : 포인터 변수 p에 저장된 포인터 주소 참조.
	- \*은 역참조 연산
	- 메모리 누수 발생 가능(malloc()t사용 후 free()로 해재 안했을 때)
	- 메모리 할당 및 해제 필요
- 참조타입
	- 메모리 객체나 값을 참조
	- c++ 참조 타입 변수는 항상 묵시적으로 역참조 되는 상수 포인터로, 어떤 변수의 주소 값으로 초기화 되어야하고 초기화 후에는 다른 변수를 참조하도록 설정 불가
	- 포인터는 역참조를 해줘야하지만, 참조타입을 알아서 된다.
	- 메모리 자동 관리
	- java는 오직 참조만 된다(객체만 가리키고, 명시적 회수가 불가능)
- 공통점
	- 데이터를 복사하지 않고 직접 참조를 통해 동일한 데이터에 접근하거나 수정할 수 있음

8. ==**다음 함수 정의를 타입 검사하고 그 타입 검사 과정을 설명하시오.(10점)**==
```
fun int f(int x) {

x = x - 1;

if (x > 0) then return x; else return -x;

}
```


9. **다음과 같이 함수 p를 호출할 때 값 전달, 참조 전달, 값-결과 전달, 이름 전달 방법을 사용했을 각 경우에 대해 호출 후의 a의 값은 무엇이며 이유를 설명하시오.(20점)**
``` c
int a = 1;

void p(int x, int y)

{
x++; y++;
}

main(){
p(a,a);
}
```

(1) 값 전달 
a : 1
이유 : p(a,a) 호출 시 a의 값이 x와 y에 각각 복사되고, 내부에서 각각 x와 y에 대해 증가 & 복사된 값에 대해 연산 & a는 변경이 없기에 유지
(2) 참조 전달
a : 3
이유 : p(a,a)호출 시 a의 메모리 주소가 x와 y에 전달 -> 함수 내부에서 x++;y++; 실행 = 같은 메모리 사용으로 a값 같이 변경됨 -> 최종적으로 a는 3이 됨
(3) 값-결과 전달 
a : 2
이유 : p(a,a)호출 시 a의 값이 각각 x와 y에 전달 -> 함수 내부에서 x++;y++;를 진행하고 그 값을 다시 a에게 돌려줌 -> 결과적으로 a는 2가 됨
(4) 이름 전달
a : 3
이유 : 함수 호출 시 a의 이름(참조)가 x와 y에 전달 -> 함수 내부에서 x++;y++;실행하고 a의 값을 읽고 증가 -> 최종적으로 a 는 3이 됨

10. ==매개변수 전달 방법으로 값 전달, 참조 전달, 값-결과 전달, 이름 전달 방법을 사용할 때 이 프로그램의 출력과 이유를 설명하시오.(20점)==
``` c
int i = 1;

int a[3] = {1, 2, 3};

void swap(int x, int y)

{ int t = x; x = y;

y = t;

}

main(){

swap(i, a[i]);

printf("%d %d %d %d\n", i, a[0], a[1], a[2]);

}
```
(1) 값 전달 
(2) 참조 전달
(3) 값-결과 전달 
(4) 이름 전달

11. ==**정적 유효범위 법칙과 동적 유효범위 법칙을 사용했을 때 다음 프로그램의 실행결과를 설명하시오.(20점)**==
``` c
int x = 0;

fun void g(int y)

x = x + y * y;

fun void f(int z)

let int x = 10; in

g(z);

print x;

end;

f(5);

print x;
```
(1) 정적 유효범위(10점)
(2) 동적 유효범위(10점)

12. ==**함수, 프로시저, 메소드, 멤버 함수를 설명하시오.(20점)**==
    - 함수
	      - 반환값이 있으므로 식이 나타날 수 있고, 매개변수나 비지역 변수 값 변경은 선택사항
	      - 특정 작업을 수행하는 코드의 묶음
	      - 코드의 재사용성을 높이고, 코드를 더 읽기 쉽게 만들며, 복잡한 작업을 단순화, 함수는 일정한 입력을 받아서 그 입력을 처리한 후, 결과를 반환하거나 특정 작업 수행
	      - 특징 : 재사용성, 가독성, 유지보수
	  - 프로시저
	    - 대부분의 프로그래밍 언어에서는 필요에 의해 리턴 값이 없는 함수를 제공한다. 리턴 값이 없는 함수
	    - 한 그룹의 계산과정 추상화하는 메커니즘
	    - 반환값이 없으면 비지역 변수 값 변경은 선택사항
	- 메소드
		- 객체지향프로그래밍 요소
		- 클래스 / 객체에 속한 함수로, 특적 객체와 관련된 행동을 정의
		- 객체의 상태(필드 또는 속성)을 참조하거나 변경 가능
		- 클래스/객체에 종속되고, 독립적 실행 불가
		- 메소드 객체 자신(self, thils)을 첫번째로 인수로 받음
	- 멤버함수
		- 객체지향프로그래밍 요소
		- 클래스 내부에 정의된 함수, 객체의 멤버(속성 또는 필드)와 함께 동작
		- 객체의 필드(속성)와 관련된 작업수행
		- 객체의 상태나 속성을 참조하거나 변경하며, 객체와 밀접한 연관
		- 

13. ==**형식매개변수, 실매개 변수, 인자, 지역변수에 대해 설명하시오(20점)**==

14. ==**프로그래밍언어에서 함수 구현을 위한 실행시간 스택과 활성 레코드에 대해 설명하시오.(10점)**==

15. **다음 프로그램에 대해 답하시오.(20점)**

	==(1) (1)과 (2) 지점에서 함수 호출 후에 프레임 스택을 그리시오.==

	(2) 이 프로그램의 출력 결과는 무엇인가?

``` c
int x = 0;

void p( ) {

int y = 3;

printf("%d\n", y);

printf("%d\n", x);

}

void r() {

x = 2; p();

}

void q() {

int x = 1; r(); (1)

p(); (2)

}

int main() {

q();

return 0;

}
```
결과 : 
3
2
3
2

16. ==**main으로부터 함수 f()까지 호출되었을 때 프레임 스택을 그리시오(20점)**==

``` c
int c, d;

void f() {

int a, b;

}

void g() {

int b, c; f( );

}

main() {

g( );

}
```

17. **예외 처리 방법으로 재개 모델과 종료 모델에 대해서 설명하시오.(10점)**
- 재개 모델
	-  예외가 발생하면 예외처리 후 예외를 발생시킨 코드로 재개하여 계속 실행하는 것. try구문에서 예외가 발생했을 때 try문(예외발생지점) -> catch문 -> try문(예외발생지점 후) 순으로 계속 실행된다. 
	- PL/I에서 채택되어 사용되었다.
- 종료모델
	- 예외가 발생하면 예외 처리 후 예외를 발생시킨 코드로 재개하지 않고 try문을 끝낸 다음 문장을 실행
	- try구문에서 예외가 발생했을 때 try문(예외발생지점) -> catch문 -> try-catch문 이후 문 순으로 실행
	- C++,Python,JAVA 등에서채택되어 사용 
18. **프로그래밍에서 예외와 예외 전파에 대해 설명하시오.(10점)**
- 예외
	- 심각하지 않은 오류 혹은 비정상적 상황
	- 프로그램에서 예외가 발생하면 이를 처리하고 계속 수행할 수 있도록 해야함
	- 보통 발생된 예외를 처리하지 못하면 프로그램은 종료됨
	- 현대 프로그래밍 언어들은 프로그램의 안전성을 지원하기 위해 예외처리를 위한 기능들을 제공
	- 예외처리를 위해서는 예외정의(프로그래머가 새로운 예외를 정의할 수 있는 기능), 예외 발생(예외를 발생시킬 수 있는 문장), 예외 처리(발생된 예외를 처리하기 위한 문장)
- 예외 전파
	-  호출된 함수 내에서 발생된 예외는 그 함수 내에서 처리되지 않으면 호출의 역순으로 처리 될 때까지 호출자 함수에게 전파되는 것
	- 예외 전파 특징을 이용하면 호출된 함수 내에서 예외를 호출자 함수에서 처리할 수 있다.
	- 이처럼 C()에서 예외가 발생하면, B()로 가고 B()에 예외처리가 없으면 예외처리가 있는 A()로 간다.
	- JAVA 
		- C만약 A()에도 없을 경우 main까지 가며, main에 없으면 프로그램 종료 
	- ![[Pasted image 20241206233802.png]]
	- 
1. **파이선으로 다음의 예외처리 코드를 작성한다.(20점)**
	1) C:\a.txt 파일이 있을 때 파일 내용을 인쇄하고 없을 때 예외처리
	``` python
		try:
			with open("a.txt", "r") as file:
				content = file.read()
		except FileNotFoundError:
			print("파일 찾을 수 없습니다.")	
	```
	3) C:\a.txt 파일에 스트링(‘telerate’)를 더하고 파일 내용을 인쇄
	``` python
		try:
			with open("a.txt", "w") as file:
				file.write("telerate")
		except IOError:
			print("파일 입출력 오류가 발생했습니다.")	
	```
20. **객체지행 프로그램(20점)**
	1) 클래스, 생성자에 대해 설명 하시오.(10점)
		- 클래스 
			- 객체의 정의 혹은 타입
			- python은 객체변수와 클래스 변수를 가지고 java에서는 클래스 정의구문, 클래스 멤버, 실체변수 등을 가지는 것처럼 언어마다 방식 다름
			- 객체의 속성과 행동을 정의해야하는데 이렇게 객체를 정의한 것
			- 클래스는 객체에 대한 설계도 역할을 하며 클래스로부터 객체들을 생성해낼 수 있다.
			- 
		- 생성자
			- 클래스와 같은 이름을 갖는 특수한 메소드로 new 연산자에 의해 객체가 생성될 때 자동으로 실행된다.
			- 주로 객체를 초기화 하는데 사용
			- 생성자는 리턴값이 없으므로 리턴 타입이 없으며 생성자에 리턴타입을 사용하면 컴파일 오류 발생
			- 클래스 정의 시 생성자 정의 필수는 아니고 필요에 따라 중복 정의로 여러개 선언 가능하다 
			- JAVA에서 생성자를 선언하지 않으면 각 클래스는 JAVA가 기본으로 제공하는 매개변수 없는 디폴트 생성자를 갖는다
	1)  접근 지정자의 종류와 차이를 설명하시오(10점)
		- private : 전용 가시성
			- 정의된 클래스 내에서만 접근 가능
			- 자식 클래스 내에서 직접 접근 불가능
			- 부모 클래스로부터 상속받은 salary 필드 변수는 직접 사용 불가능으로 super 사용
		- public : 공용 가시성
			- 자식 클래스 뿐만 아니라 프로그램 내 어디서나 접근 가능
			- 공용변수는 캡슐화 원리를 위반
		- package 
			- 아무 접근 지정자도 기술하지 않을 때 package 혹은 default 가시성
			- 같은 패키지 내에서는 자유 접근 가능하지만 패키지 외부는 접근 불가능
		- protected : protected 가시성
			- 상속을 위한 제 3의 가시성
			- 공용가시성 보다는 더 캡슐화하고, 전용보다는 덜 캡슐화, 정의된 클래스 내와 그 자손 클래스에서 접근 가능
			- protected 멤버는 클래스 내부와 이 클래스이 자손 클래스에서 접근 가능 + 같은 패키지 내에 있는 클래스들은 모두 접근 가능