
1 . <span style='background-color : #FFE6E6; color:black'>**구조적 프로그래밍을 위한 세 가지 제어구조에 대해 설명하시오.(10)**</span>
- 구조적 프로그래밍은 goto 문을 사용하지 않고, 시작과 끝나는 지점이 일정한 구조적 구문을 사용하자는 것
- 각각의 구조와 그 사이의 관계를 이해하면 프로그램 전체를 보다 쉽게 이해할 수 있다는 장점
- 간단 + 계층적인 제어구조
	1. 순차 
		1. 구문 순서에 따라서 순서대로 수행하는 것 
	2. 선택 
		1. 프로그램의 상태에 따라서 여러 구문들 중에서 **하나를 수행**하는 것, if, switch 와 같은 키워드 사용
	3. 반복
		1. 프로그램이 특정한 상태에 도달할 때까지 구문을 반복하여 수행하거나 집합체의 각각의 원소들에 대해 어떤 구문을 반복 수행하는 것, while, repeat, for와 같은 키워드로 표현

==2 . **if-문을 사용하여 다음 switch-문과 똑같은 일을 하도록 작성하시오(10점)**==

``` python
switch (E) {

case a : S1; break; case b : S2; break;

case c : S3; break;

}
```
-----
``` python
if (E == a) { S1; } 
else if (E == b) { S2; } 
else if (E == c) { S3; }
```

<span style='background-color : #FFE6E6; color:black'>3 . **정적 타입 언어와 동적 타입 언어에 대해서 설명하시오.(5점)**</span>
	1. 정적타입언어 
		1. 변수의 타입이 컴파일 시간에 결정되어 고정되는 언어로 보통 타입 검사도 컴파일 시간에 한다.
		2. JAVA, C, C++, FORTRAN, Pascal, Scala 등이 대표적
		3. JAVA, C, C++에서 string 타입으로 선언된 변수 name은 한 번 타입 선언되면 타입이 고정되어 변할 수 없다 . (JAVA 예시 : String name; name = "joo"; name = 35; //오류 발생)
	2. 동적타입언어
		1. 변수의 타입이 고정되지 않고 실행중에 변하는 언어로 타입 검사도 인터프리터에 의해서 **실행 중에** 이뤄진다.
		2. JavaScript, Perl, Python, Sheme 등이 대표적
		3. Python경우 type연산자를 통해 확인 가능
		4. JavaScript를 예로 들었을 때 변수 name은 선언된 타입이 없고 **대입값에 따라 타입이 변경됨** ( var name; name="joo"; name =34; //오류 발생 X)
<span style='background-color : #FFE6E6; color:black'>**４. 다음 Python의 예를 실행하고 결과를 타입 관점에서 설명하시오.(20점)**</span>
``` python
>> def add(a,b): return a+b
>> add(5, 10.0)
  
>> add(5, “10”)	
  
>> add(“hello”, “world”)

>> add([1,3,5], [7,9])

```
1) 15.0
   a = 5(성수, int), b = 10.0(실수, float)
   python에서 int + float 연산은 자동으로 float 로 변환하여 실수로 반환
   python은 **숫자 연산에서 더 정밀한 타입을 유지하려고 함** 
2) Type Error : unsupportted operand type(s) for + : int and str
   a=5(정수, int) b="10"(문자열, str)
   python은 int와 str 연산을 자동으로 해주지 않음
   따라서 TypeError 발생하고, **계산하려면 문자열 변경후 연산 해야함**
3) a="hello"(문자열, str) , b="world"(문자열, str)
   python에서 str + str은 **결합하는** 연산으로 helloworld 출력
4) a=[1,3,5], b=[7, 9]
   a=[1,3,5] (리스트, list), b = [7,9] (리스트, list)
   python은 리스트에 대해 덧셈 연산자를 리스트 **연결연산**으로 해석
   **새로운리스트 반환**

<span style='background-color : #FFE6E6; color:black'>5 . **자료구조에서 배열과 스택에 대해 설명하시오(10점)**</span>
- 배열 
	- 같은 타입의 <span style='color:yellow'>연속된 </span>변수들로 구성된 자료형
	- 배열을 구성하는 변수 하나하나를 배열 요소라고 하고, ㄹ배열요소는 배열 이름과 인덱스 로 표현 가능
	- <span style='color:yellow'>1차원 배열과 2차원 배열, 그 이상의 배열이 있지만, 기본적으로 배열은 1차원 **메모리에 저장**된다. </span>
	- 인덱스를 통해서 빠른 접근이 가능하고, 인덱스는 0에서부터 시작된다.
	- 언어별로 배열 크기가 동적으로 결정되는 시점이 다르지만, 배열의 크기가 한 번 결정되면 그 크기는 고정되는 것은 동일하다.
	- 단순 데이터 저장
- 스택
	- LIFO 원칙을 따르는 선형 데이터 구조 
	- 가장 최근에 삽입된 데이터가 가장 먼저 제거됨
	- 삽입(push) 삭제(pop)는 스택의 맨 위(top)에서만 수행
	- 파이썬 기준으로 할 때 stack을 선언시 배열을 사용하여 생성할 수 있다.
		stack = []
		stack.append(10) #push
		stack.append(20)
		print(stack.pop()) #pop 
	- 스택은 크기를 초과할 경우 스택오버플로우 발생, 이를 해결하기 위해 동적배열을 사용하여 배열 크기를 자동으로 늘릴 수 있다. (python 리스트 사용)
	- 특정 알고리즘(**깊이우선탐색**  등) 에서 유용
- 공통점 
	- 선형데이터 구조, 인덱스 기반 저장, 연속된 메모리 

<span style='background-color : #FFE6E6; color:black'>6 . **강한 타입 언어와 약한 타입 언어에 대해서 설명하시오(5점)**</span>
- 강한 타입 언어 
	- 엄격한 타입 규칙을 적용하여(=가능한 모든) 타입오류를 찾아낼 수 있는 언어를 강한타입 언어
	- JAVA, C#, Python 등
	- <span style='color:yellow'>자동타입 변환을 하지않고 </span> 엄격한 타입 규칙을 적용하여 타입검사를 하기때문에 이를 통과한 프로그램은 실행 중에 타입 오류가 바랭하지 않음
- 약한 타입 언어
	- 느슨한 타입 규칙을 적용하여 타입 오류를 찾아내는 언어
	- C/C++, JavaScript, PHP 등
	- <span style='color:yellow'>자동 타입 변환을 하고</span> 타입규칙이 엄격하지 않아서 타입규칙을 적용하여 타입 검사를 하더라도 해당 검사를 통과한 프로그램이 실행중에 타입 오류가 발생할 수 있음
- 강한정적타입언어 : JAVA
- 약한정적타입언어 : C
- 강한동적타입언어 : Python
- 약한동적타입언어 : JavaScript

<span style='background-color : #FFE6E6; color:black'>7 . **포인터 타입과 참조 타입에 대해서 자세히 설명하시오(20점)**</span>
- 포인터 타입
	- 메모리 위치(주소)를 값으로 사용하는 자료형
	- 대표적으로 C, C에서는 메모리 위치도 하나의 값처럼 사용할 수 있으며 이를 포인터라고 부름
	- c를 기준
		``` c
		T *p; // 포인터 변수 선언
		p = E; //포인터 변수에 대입
		*p = E; // 포인터가 참조하는 변수에 대입
		```
		- malloc(n) : 크기 n의 메모리 할당 및 시작 주소 반환
		- <span style='color : yellow'>&x : 변수 x의 포인터(주소)</span>
		- \*p : 포인터 변수 p가 참조하는 변수의 값을 반환
	- <span style='color:yellow'>*은 역참조 연산</span>
	- <span style='color:yellow'>메모리 누수 발생 가능</span>(malloc()t사용 후 free()로 해재 안했을 때)
	- 메모리 할당 및 해제 필요
- 참조타입
	- 메모리 <span style='color:yellow'>객체나 값</span>을 참조
	- c++ 참조 타입 변수는 항상 **묵시적으로 역참조 되는 상수 포인터**로, 어떤 변수의 주소 값으로 초기화 되어야하고 초기화 후에는 다른 변수를 참조하도록 설정 불가
	- 포인터는 역참조를 해줘야하지만, 참조타입을 알아서 된다.
	- 메모리 자동 관리
	- java는 오직 참조만 된다(객체만 가리키고, 명시적 **회수**가 불가능)

<span style='background-color : #FFE6E6; color:black'>8 . **다음 함수 정의를 타입 검사하고 그 타입 검사 과정을 설명하시오.(10점)**</span>
```
fun int f(int x) {

x = x - 1;

if (x > 0) then return x; else return -x;

}
```

- x = x - 1은 변수의 값을 갱신하는 대입문으로 void 타입.
- if 문에서 조건식(x > 0)은 bool 타입이며, 두 return 문은 모두 int 타입.
- if-else 문 전체의 타입은 int.
- <span style='color:yellow'>첫 번째 문장이 void, 두 번째 문장이 int이므로 **복합문의** 타입은 int.</span>
- 함수의 반환 타입이 int이고, 내부 구현도 int 타입을 반환하므로 타입 검사를 통과.
<span style='background-color : #FFE6E6; color:black'>9 . **다음과 같이 함수 p를 호출할 때 값 전달, 참조 전달, 값-결과 전달, 이름 전달 방법을 사용했을 각 경우에 대해 호출 후의 a의 값은 무엇이며 이유를 설명하시오.(20점)**</span>
``` c
int a = 1;

void p(int x, int y)

{
x++; y++;
}

main(){
p(a,a);
}
```

1-1. 값 전달
p(a,a)를 하고 p함수에 a에 대한 주소가 아닌 값만 전달이 됨. 
함수 내부에서는 전달받은 값을 가지고 연산을 하고 끝나기 때문에 a의 값이 변경되는 것은 없다.
따라서 a는 1이됨
x++; -> x=2; y++; -> y=2 a는 영향 x


1-2 참조전달
p(a,a)를호출 할 때 값이 아닌 a의 주소가 전달된다. 
x++;했을 때 실제 a주소의 값이 증가하여 a는 2가 되고, y++;을 했을 때 동일하게 a의 주소의 값이 증가하여 a는 3이되고 함수가 종료된다. 
따라서 최종 a는 3이 된다.
x++; -> a=2
y++; -> a=3

1-3. 값-결과 전달
p(a,a)를 호출했을 때



함수 내부에서 각각 x와y는 독립적으로 연산이 된다. 
x++;와 y++;를 연산하고 그 값을 다시 호출자 변수인 a에게 돌려준다. 
마지막 연산 결과가 y++;이므로 a의 값은 2가 된다.
x++; -> x=2
y++; -> y=2 -> a는 2가 된다.

1-4. 이름 전달 
p(a,a)를 했을 때 a의 표현(식)이 x와y에 전달된다. 
그 후 x++할 때 a자체가 ++되는 것으로 2가 되고, y++할 때 a자체가 ++되어 3이된다.
따라서 최종적 값은 3이된다.
x++; -> a=2
y++; -> a=3

<span style='background-color : #FFE6E6; color:black'>10 .  매개변수 전달 방법으로 값 전달, 참조 전달, 값-결과 전달, 이름 전달 방법을 사용할 때 이 프로그램의 출력과 이유를 설명하시오.(20점)</span>
``` c
int i = 1;

int a[3] = {1, 2, 3};

void swap(int x, int y)

{ int t = x; x = y;

y = t;

}

main(){

swap(i, a[i]);

printf("%d %d %d %d\n", i, a[0], a[1], a[2]);

}
```
(1) 값 전달 
- 1 1 2 3
- x와 y는 i=1과 a[i]=2의 값을 받아 함수 내부에서 x,y값만 변경된다 .
- 함수 끝난 후 x와 y는 함수 내부에서만 영향을 미치고 전역변수 i,a는 변하지 않는다.
(2) 참조 전달
- 2 1 1 3
- x와 y는 i와 a[i]의 주소를 받는다, x는 i의 주소를 참조하므로 i의 값이 함수에서 변경된 대로 변경된다. y또한 a[i]의 주소를 참조하므로 a[1]값도 변경된다.
(3) 값-결과 전달 
- 2 1 1 3
- x와 y의 값은 i와 a[i]의 값을 전달 받고, 서로 교환된 후 그 결과가 i와 a[i]에 적용된다.
(4) 이름 전달
- 2 1 2 1
- 함수 호출 시 값이 아닌 표현식이 전달되어, <span style='background-color:red; color:yellow'>동적으로 참조대상 변경된다.</span>
- x 는 i로, y는 a[i]로 인식하여 값 교환이 이뤄진다.

==11 . **정적 유효범위 법칙과 동적 유효범위 법칙을 사용했을 때 다음 프로그램의 실행결과를 설명하시오.(20점)**==
``` python
int x = 0;
fun void g(int y)
	x = x + y * y;

fun void f(int z)
	let int x = 10; in
		g(z);
		print x;
	end;

f(5);
print x;
```
(1) 정적 유효범위(10점)
	(결과)
	10
	25
- f(5) 호출
- 함수내에서 새로 x가 선언됨
- g(z)호출 시 y에 5가 전달되고, g함수에서 **전역변수** x를 사용하여 계산한다. ( 전역변수 x = 25됨 )
- f함수에서 x는 지역변수 x의 값으로 10이 출력되고, print x;는 전역변수 x가 출력되기 때문에 25가 출력된다.
(2) 동적 유효범위(10점)
	(결과)
	35
	0
1.  f(5)호출
2. f함수 내에서지역변수 x 선언
3. g(z)호출 시 동적 유효 범위에서는 <span style='color:yellow'>**현재 실행중인 함수 스택에서 x를 참조</span>**하기에 g함수는 f함수의 x=10을 참조함
4. g(5) 실행시 x가 35으로 변경되어 f함수 내의 print x는 35
5. 전역변수 print x는 0을 출력
<span style='background-color : #FFE6E6; color:black'>12 . **함수, 프로시저, 메소드, 멤버 함수를 설명하시오.(20점)**</span>
    - 함수
	      - 반환값이 있으므로 식이 나타날 수 있고, 매개변수나 비지역 변수 값 변경은 선택사항
	      - 특정 작업을 수행하는 <span style='color:yellow'>코드의 묶음</span>
	      - 코드의 재사용성을 높이고, 코드를 더 읽기 쉽게 만들며, 복잡한 작업을 단순화, 함수는 일정한 입력을 받아서 그 입력을 처리한 후, 결과를 반환하거나 특정 작업 수행
	      - <span style='color:yellow'>특징 : 재사용성, 가독성, 유지보수</span>
	  - 프로시저
	    - 리턴 값이 없는 함수
	    - <span style='color:yellow'>**한 그룹의 계산과정 추상화하는 메커니즘**</span>
	    - 반환값이 없으면 비지역 변수 값 변경은 선택사항
	- 메소드
		- 객체지향프로그래밍 요소
		- 클래스 / 객체에 속한 함수로, 특적 객체와 관련된 행동을 정의
		- 객체의 상태(필드 또는 속성)을 참조하거나 변경 가능
		- 클래스/객체에 종속되고, 독립적 **실행 불가**
		- <span style='color:yellow'>메소드 객체 자신(self/this)을 첫번째로 인수로 받음</span>
	- 멤버함수
		- 객체지향프로그래밍 요소
		- 클래스 내부에 정의된 함수, 
		- <span style='color:yellow'>객체의 멤버(속성 또는 필드)와 함께 동작
		- 객체의 필드(속성)와 관련된 작업수행</span>
		- 객체의 상태나 속성을 참조하거나 변경하며, 객체와 밀접한 연관

<span style='background-color : #FFE6E6; color:black'>13 . **형식매개변수, 실매개 변수, 인자, 지역변수에 대해 설명하시오(20점)**</span>
- 형식 매개변수 
	- 함수 정의에서 사용된 매개변수
	- 함수 내에서 로컬 변수처럼 사용되고, 함수가 호출 될 때 실제 인자가 형식 매개변수에 전달됨
	- int add(int a, int b){ return a+b;} 에서 a 와 b는 형식 매개변수
- 실매개변수
	- 함수가 호출될 때 형식 매개변수에 전달되는 값이나 변수
	- a = 3, b= 5일 때, int result = add(a,b); 여기서 3,5가 실 매개변수
- 인자
	- 실 매개변수와 같은 의미로 사용되지만, 전달되는 실제 값을 강조
	- 함수 호출 시 형식 매개변수에 전달되는 실제 값이고<span style='color : yellow'>  함수의 형식 매개변수에 값을 전달하여 함수가 그 값을 이용해 작업을 수행</span>
	- add(3,5) 에서 3,5는 인자
- 지역변수
	- 함수나 메소드 내부에 선언된 변수
	- <span style='color:yellow'>해당 함수가 실행되는 동안만 존재 </span>
	- <span style='color:yellow'>함수 외부에서는 접근할 수 없으며 </span>함수가 끝나면 자동으로 소멸
	- 지역변수는 함수의 실행과정에서만 필요하고 함수가 종료되면 메모리에서 해제된다.

<span style='background-color : #FFE6E6; color:black'>14 . **프로그래밍언어에서 함수 구현을 위한 실행시간 스택과 활성 레코드에 대해 설명하시오.(10점)**</span>
- 실행시간 스택
	- **프로그램이 실행되는 동안** 함수 호출과 반환을 관리하는 스택 자료구조
	- 함수 호출에 필요한 지역변수, 매개변수, 반환 값, 반환주소 등을 위한 기억공간이 할당됨
	- <span style='color:yellow'>LIFO 방식으로 사용 & 재귀호출 구현 가능</span>
	- 함수 호출하면 새로운 스택 프레임(호출에 필요한 정보 포함) 생성 -> 함수가 끝날(반활될) 때마다 호출할 때  만든 프레임 제거
- 활성 레코드
	- 함수 호출 시 실행시간 스택에 푸시되는 데이터 구조
	- 스택 프레임이라고 불리며 함수 호출 시 해당 함수에 필요한 정보 저장
	- 구성요소 : 매개변수, 지역변수, 반환주소, 동적링크, 정적링크
	- 스택 프레임을 생성하여 함수 실행 시 필요한 모든 정보를 저장, 반환주소는 함수 끝난 후 실행 흐름을 원래의 호출 지점으로 복귀 시키는데 사용
- 
<span style='background-color : #FFE6E6; color:black'>15 . **다음 프로그램에 대해 답하시오.(20점)**</span>
	<span style='background-color : #FFE6E6; color:red'>*(1) (1)과 (2) 지점에서 함수 호출 후에 프레임 스택을 그리시오.</span>
	(2) 이 프로그램의 출력 결과는 무엇인가?

``` c
int x = 0;

void p( ) {

int y = 3;

printf("%d\n", y);

printf("%d\n", x);

}

void r() {

x = 2; p();

}

void q() {

int x = 1; r(); (1)

p(); (2)

}

int main() {

q();

return 0;

}
```
결과 : 
3
2
3
2

16 . <span style='background-color : #FFE6E6; color:red'>*main으로부터 함수 f()까지 호출되었을 때 프레임 스택을 그리시오(20점)**</span>

``` c
int c, d;

void f() {

int a, b;

}

void g() {

int b, c; f( );

}

main() {

g( );

}
```

<span style='background-color : #FFE6E6; color:black'>17 . **예외 처리 방법으로 재개 모델과 종료 모델에 대해서 설명하시오.(10점)**</span>
- 재개 모델
	-  예외가 발생하면 예외처리 후 예외를 발생시킨 코드로 재개하여 계속 실행하는 것. try구문에서 예외가 발생했을 때 try문(예외발생지점) -> catch문 -> try문(예외발생지점 후) 순으로 계속 실행된다. 
	- PL/I에서 채택되어 사용되었다.
- 종료모델
	- 예외가 발생하면 예외 처리 후 예외를 발생시킨 코드로 재개하지 않고 try문을 끝낸 다음 문장을 실행
	- try구문에서 예외가 발생했을 때 try문(예외발생지점) -> catch문 -> try-catch문 이후 문 순으로 실행
	- C++,Python,JAVA 등에서채택되어 사용 
<span style='background-color : #FFE6E6; color:red'>18 . **프로그래밍에서 예외와 예외 전파에 대해 설명하시오.(10점)**</span>
- 예외
	- 심각하지 않은 오류 혹은 비정상적 상황
	- 프로그램에서 예외가 발생하면 이를 처리하고 계속 수행할 수 있도록 해야함
	- 보통 발생된 예외를 처리하지 못하면 프로그램은 종료됨
	- <span style='color:yellow'>현대 프로그래밍 언어들은 프로그램의 안전성을 지원하기 위해 예외처리를 위한 기능들을 제공</span>
	- 예외처리를 위해서는 예외정의(프로그래머가 새로운 예외를 정의할 수 있는 기능), 예외 발생(예외를 발생시킬 수 있는 문장), 예외 처리(발생된 예외를 처리하기 위한 문장)
- 예외 전파
	-  호출된 함수 내에서 발생된 예외는 그 함수 내에서 처리되지 않으면 호출의 역순으로 처리 될 때까지 호출자 함수에게 전파되는 것
	- 예외 전파 특징을 이용하면 호출된 함수 내에서 예외를 호출자 함수에서 처리할 수 있다.
	- 이처럼 C()에서 예외가 발생하면, B()로 가고 B()에 예외처리가 없으면 예외처리가 있는 A()로 간다.
	- JAVA 
		- C만약 A()에도 없을 경우 main까지 가며, main에 없으면 프로그램 종료 
	- ![[Pasted image 20241206233802.png]]
	- 
==19 . **파이선으로 다음의 예외처리 코드를 작성한다.(20점)**==
	1) C:\a.txt 파일이 있을 때 파일 내용을 인쇄하고 없을 때 예외처리
	``` python
		try:
			with open("a.txt", "r") as file:
				content = file.read()
				print(content)
		except FileNotFoundError:
			print("파일 찾을 수 없습니다.")	
	```
	3) C:\a.txt 파일에 스트링(‘telerate’)를 더하고 파일 내용을 인쇄
	``` python
		try:
			with open("a.txt", "a") as file:
				file.write("telerate")
				
			with open("a.txt", "r") as file:
				content = file.read()
				print(content)
		except IOError:
			print("파일 입출력 오류가 발생했습니다.")	
	```
20. <span style='background-color : #FFE6E6; color:black'>**객체지행 프로그램(20점)**</span>
	1) <span style='background-color : #FFE6E6; color:red'>*클래스, 생성자에 대해 설명 하시오.(10점)</span>
		- 클래스 
			- 객체의 정의 혹은 타입
			- python은 객체변수와 클래스 변수를 가지고 java에서는 클래스 정의구문, 클래스 멤버, 실체변수 등을 가지는 것처럼 언어마다 방식 다름
			- 객체의 속성과 행동을 정의해야하는데 이렇게 객체를 정의한 것
			- 클래스는 객체에 대한 설계도 역할을 하며 클래스로부터 객체들을 생성해낼 수 있다
		- 생성자
			- 클래스와 같은 이름을 갖는 특수한 메소드로 new 연산자에 의해 객체가 생성될 때 자동으로 실행된다.
			- <span style='color:yellow'>주로 객체를 초기화 하는데 사용</span>
			- 생성자는 <span style='color:yellow'>리턴값이 없으므로 </span>리턴 타입이 없으며 생성자에 리턴타입을 사용하면 컴파일 오류 발생
			- 클래스 정의 시 생성자 정의 필수는 아니고 필요에 따라 중복 정의로 여러개 선언 가능하다 
			- JAVA에서 생성자를 선언하지 않으면 각 클래스는 JAVA가 기본으로 제공하는 매개변수 없는 디폴트 생성자를 갖는다
	1) <span style='background-color : #FFE6E6; color:red'>* 접근 지정자의 종류와 차이를 설명하시오(10점)</span>
		- private : 전용 가시성
			- 정의된 클래스 내에서만 접근 가능.
			- 자식 클래스에서 `private`으로 선언된 부모 클래스 멤버에 직접 접근 불가능
			- 부모 클래스의 `private` 멤버에 접근하려면 `protected` 또는 `public` 메소드를 통해 간접적으로 접근해야 함.
		- public : 공용 가시성
			- 자식 클래스 뿐만 아니라 프로그램 내 어디서나 접근 가능
			- 공용변수는 캡슐화 원리를 위반
		- package 
			- 아무 접근 지정자도 기술하지 않을 때 package 혹은 default 가시성
			- 같은 패키지 내에서는 자유 접근 가능하지만 패키지 외부는 접근 불가능
		- protected : protected 가시성
		   - 정의된 클래스 내부와 **같은 패키지** 내의 다른 클래스에서 접근 가능.
		   - 다른 패키지에 속한 경우, 상속받은 자식 클래스에서만 접근 가능.
		   - 상속 관계에서 부모 클래스의 멤버를 자식 클래스에서 직접 사용할 수 있음.
		   - <span style='color:yellow'>상속을 통해 부모 클래스의 기능을 재사용하도록 설계된 접근 수준.</span>
